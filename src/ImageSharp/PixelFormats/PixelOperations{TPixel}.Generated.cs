// Copyright (c) Six Labors and contributors.
// Licensed under the Apache License, Version 2.0.
// <auto-generated />

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace SixLabors.ImageSharp.PixelFormats
{
    public partial class PixelOperations<TPixel>
    {
        /// <summary>
        /// Converts all pixels in 'source` span of <see cref="Argb32"/> into a span of <typeparamref name="TPixel"/>-s.
        /// </summary>
        /// <param name="source">The source <see cref="Span{T}"/> of <see cref="Argb32"/> data.</param>
        /// <param name="destPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        internal virtual void FromArgb32(ReadOnlySpan<Argb32> source, Span<TPixel> destPixels)
        {
            Guard.DestinationShouldNotBeTooShort(source, destPixels, nameof(destPixels));
            
            ref Argb32 sourceBaseRef = ref MemoryMarshal.GetReference(source);
            ref TPixel destBaseRef = ref MemoryMarshal.GetReference(destPixels);

            for (int i = 0; i < source.Length; i++)
            {
                ref Argb32 sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref TPixel dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromArgb32(sp);
            }
        }

        /// <summary>
        /// A helper for <see cref="FromArgb32(ReadOnlySpan{Argb32}, Span{TPixel})"/> that expects a byte span.
        /// The layout of the data in 'sourceBytes' must be compatible with <see cref="Argb32"/> layout.
        /// </summary>
        /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
        /// <param name="destPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void FromArgb32Bytes(ReadOnlySpan<byte> sourceBytes, Span<TPixel> destPixels, int count)
        {
            this.FromArgb32(MemoryMarshal.Cast<byte, Argb32>(sourceBytes).Slice(0, count), destPixels);
        }

        /// <summary>
        /// Converts all pixels of the 'sourcePixels` span to a span of <see cref="Argb32"/>-s.
        /// </summary>
        /// <param name="sourcePixels">The span of source pixels</param>
        /// <param name="destPixels">The destination span of <see cref="Argb32"/> data.</param>
        internal virtual void ToArgb32(ReadOnlySpan<TPixel> sourcePixels, Span<Argb32> destPixels)
        {
            Guard.DestinationShouldNotBeTooShort(sourcePixels, destPixels, nameof(destPixels));

            ref TPixel sourceBaseRef = ref MemoryMarshal.GetReference(sourcePixels);
            ref Argb32 destBaseRef = ref MemoryMarshal.GetReference(destPixels);

            for (int i = 0; i < sourcePixels.Length; i++)
            {
                ref TPixel sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref Argb32 dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromScaledVector4(sp.ToScaledVector4());
            }
        }

        /// <summary>
        /// A helper for <see cref="ToArgb32(ReadOnlySpan{TPixel}, Span{Argb32})"/> that expects a byte span as destination.
        /// The layout of the data in 'destBytes' must be compatible with <see cref="Argb32"/> layout.
        /// </summary>
        /// <param name="sourcePixels">The <see cref="Span{T}"/> to the source pixels.</param>
        /// <param name="destBytes">The <see cref="Span{T}"/> to the destination bytes.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void ToArgb32Bytes(ReadOnlySpan<TPixel> sourcePixels, Span<byte> destBytes, int count)
        {
            this.ToArgb32(sourcePixels.Slice(0, count), MemoryMarshal.Cast<byte, Argb32>(destBytes));
        }

        /// <summary>
        /// Converts all pixels in 'source` span of <see cref="Bgr24"/> into a span of <typeparamref name="TPixel"/>-s.
        /// </summary>
        /// <param name="source">The source <see cref="Span{T}"/> of <see cref="Bgr24"/> data.</param>
        /// <param name="destPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        internal virtual void FromBgr24(ReadOnlySpan<Bgr24> source, Span<TPixel> destPixels)
        {
            Guard.DestinationShouldNotBeTooShort(source, destPixels, nameof(destPixels));
            
            ref Bgr24 sourceBaseRef = ref MemoryMarshal.GetReference(source);
            ref TPixel destBaseRef = ref MemoryMarshal.GetReference(destPixels);

            for (int i = 0; i < source.Length; i++)
            {
                ref Bgr24 sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref TPixel dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromBgr24(sp);
            }
        }

        /// <summary>
        /// A helper for <see cref="FromBgr24(ReadOnlySpan{Bgr24}, Span{TPixel})"/> that expects a byte span.
        /// The layout of the data in 'sourceBytes' must be compatible with <see cref="Bgr24"/> layout.
        /// </summary>
        /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
        /// <param name="destPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void FromBgr24Bytes(ReadOnlySpan<byte> sourceBytes, Span<TPixel> destPixels, int count)
        {
            this.FromBgr24(MemoryMarshal.Cast<byte, Bgr24>(sourceBytes).Slice(0, count), destPixels);
        }

        /// <summary>
        /// Converts all pixels of the 'sourcePixels` span to a span of <see cref="Bgr24"/>-s.
        /// </summary>
        /// <param name="sourcePixels">The span of source pixels</param>
        /// <param name="destPixels">The destination span of <see cref="Bgr24"/> data.</param>
        internal virtual void ToBgr24(ReadOnlySpan<TPixel> sourcePixels, Span<Bgr24> destPixels)
        {
            Guard.DestinationShouldNotBeTooShort(sourcePixels, destPixels, nameof(destPixels));

            ref TPixel sourceBaseRef = ref MemoryMarshal.GetReference(sourcePixels);
            ref Bgr24 destBaseRef = ref MemoryMarshal.GetReference(destPixels);

            for (int i = 0; i < sourcePixels.Length; i++)
            {
                ref TPixel sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref Bgr24 dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromScaledVector4(sp.ToScaledVector4());
            }
        }

        /// <summary>
        /// A helper for <see cref="ToBgr24(ReadOnlySpan{TPixel}, Span{Bgr24})"/> that expects a byte span as destination.
        /// The layout of the data in 'destBytes' must be compatible with <see cref="Bgr24"/> layout.
        /// </summary>
        /// <param name="sourcePixels">The <see cref="Span{T}"/> to the source pixels.</param>
        /// <param name="destBytes">The <see cref="Span{T}"/> to the destination bytes.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void ToBgr24Bytes(ReadOnlySpan<TPixel> sourcePixels, Span<byte> destBytes, int count)
        {
            this.ToBgr24(sourcePixels.Slice(0, count), MemoryMarshal.Cast<byte, Bgr24>(destBytes));
        }

        /// <summary>
        /// Converts all pixels in 'source` span of <see cref="Bgra32"/> into a span of <typeparamref name="TPixel"/>-s.
        /// </summary>
        /// <param name="source">The source <see cref="Span{T}"/> of <see cref="Bgra32"/> data.</param>
        /// <param name="destPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        internal virtual void FromBgra32(ReadOnlySpan<Bgra32> source, Span<TPixel> destPixels)
        {
            Guard.DestinationShouldNotBeTooShort(source, destPixels, nameof(destPixels));
            
            ref Bgra32 sourceBaseRef = ref MemoryMarshal.GetReference(source);
            ref TPixel destBaseRef = ref MemoryMarshal.GetReference(destPixels);

            for (int i = 0; i < source.Length; i++)
            {
                ref Bgra32 sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref TPixel dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromBgra32(sp);
            }
        }

        /// <summary>
        /// A helper for <see cref="FromBgra32(ReadOnlySpan{Bgra32}, Span{TPixel})"/> that expects a byte span.
        /// The layout of the data in 'sourceBytes' must be compatible with <see cref="Bgra32"/> layout.
        /// </summary>
        /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
        /// <param name="destPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void FromBgra32Bytes(ReadOnlySpan<byte> sourceBytes, Span<TPixel> destPixels, int count)
        {
            this.FromBgra32(MemoryMarshal.Cast<byte, Bgra32>(sourceBytes).Slice(0, count), destPixels);
        }

        /// <summary>
        /// Converts all pixels of the 'sourcePixels` span to a span of <see cref="Bgra32"/>-s.
        /// </summary>
        /// <param name="sourcePixels">The span of source pixels</param>
        /// <param name="destPixels">The destination span of <see cref="Bgra32"/> data.</param>
        internal virtual void ToBgra32(ReadOnlySpan<TPixel> sourcePixels, Span<Bgra32> destPixels)
        {
            Guard.DestinationShouldNotBeTooShort(sourcePixels, destPixels, nameof(destPixels));

            ref TPixel sourceBaseRef = ref MemoryMarshal.GetReference(sourcePixels);
            ref Bgra32 destBaseRef = ref MemoryMarshal.GetReference(destPixels);

            for (int i = 0; i < sourcePixels.Length; i++)
            {
                ref TPixel sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref Bgra32 dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromScaledVector4(sp.ToScaledVector4());
            }
        }

        /// <summary>
        /// A helper for <see cref="ToBgra32(ReadOnlySpan{TPixel}, Span{Bgra32})"/> that expects a byte span as destination.
        /// The layout of the data in 'destBytes' must be compatible with <see cref="Bgra32"/> layout.
        /// </summary>
        /// <param name="sourcePixels">The <see cref="Span{T}"/> to the source pixels.</param>
        /// <param name="destBytes">The <see cref="Span{T}"/> to the destination bytes.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void ToBgra32Bytes(ReadOnlySpan<TPixel> sourcePixels, Span<byte> destBytes, int count)
        {
            this.ToBgra32(sourcePixels.Slice(0, count), MemoryMarshal.Cast<byte, Bgra32>(destBytes));
        }

        /// <summary>
        /// Converts all pixels in 'source` span of <see cref="Gray8"/> into a span of <typeparamref name="TPixel"/>-s.
        /// </summary>
        /// <param name="source">The source <see cref="Span{T}"/> of <see cref="Gray8"/> data.</param>
        /// <param name="destPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        internal virtual void FromGray8(ReadOnlySpan<Gray8> source, Span<TPixel> destPixels)
        {
            Guard.DestinationShouldNotBeTooShort(source, destPixels, nameof(destPixels));
            
            ref Gray8 sourceBaseRef = ref MemoryMarshal.GetReference(source);
            ref TPixel destBaseRef = ref MemoryMarshal.GetReference(destPixels);

            for (int i = 0; i < source.Length; i++)
            {
                ref Gray8 sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref TPixel dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromGray8(sp);
            }
        }

        /// <summary>
        /// A helper for <see cref="FromGray8(ReadOnlySpan{Gray8}, Span{TPixel})"/> that expects a byte span.
        /// The layout of the data in 'sourceBytes' must be compatible with <see cref="Gray8"/> layout.
        /// </summary>
        /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
        /// <param name="destPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void FromGray8Bytes(ReadOnlySpan<byte> sourceBytes, Span<TPixel> destPixels, int count)
        {
            this.FromGray8(MemoryMarshal.Cast<byte, Gray8>(sourceBytes).Slice(0, count), destPixels);
        }

        /// <summary>
        /// Converts all pixels of the 'sourcePixels` span to a span of <see cref="Gray8"/>-s.
        /// </summary>
        /// <param name="sourcePixels">The span of source pixels</param>
        /// <param name="destPixels">The destination span of <see cref="Gray8"/> data.</param>
        internal virtual void ToGray8(ReadOnlySpan<TPixel> sourcePixels, Span<Gray8> destPixels)
        {
            Guard.DestinationShouldNotBeTooShort(sourcePixels, destPixels, nameof(destPixels));

            ref TPixel sourceBaseRef = ref MemoryMarshal.GetReference(sourcePixels);
            ref Gray8 destBaseRef = ref MemoryMarshal.GetReference(destPixels);

            for (int i = 0; i < sourcePixels.Length; i++)
            {
                ref TPixel sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref Gray8 dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromScaledVector4(sp.ToScaledVector4());
            }
        }

        /// <summary>
        /// A helper for <see cref="ToGray8(ReadOnlySpan{TPixel}, Span{Gray8})"/> that expects a byte span as destination.
        /// The layout of the data in 'destBytes' must be compatible with <see cref="Gray8"/> layout.
        /// </summary>
        /// <param name="sourcePixels">The <see cref="Span{T}"/> to the source pixels.</param>
        /// <param name="destBytes">The <see cref="Span{T}"/> to the destination bytes.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void ToGray8Bytes(ReadOnlySpan<TPixel> sourcePixels, Span<byte> destBytes, int count)
        {
            this.ToGray8(sourcePixels.Slice(0, count), MemoryMarshal.Cast<byte, Gray8>(destBytes));
        }

        /// <summary>
        /// Converts all pixels in 'source` span of <see cref="Gray16"/> into a span of <typeparamref name="TPixel"/>-s.
        /// </summary>
        /// <param name="source">The source <see cref="Span{T}"/> of <see cref="Gray16"/> data.</param>
        /// <param name="destPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        internal virtual void FromGray16(ReadOnlySpan<Gray16> source, Span<TPixel> destPixels)
        {
            Guard.DestinationShouldNotBeTooShort(source, destPixels, nameof(destPixels));
            
            ref Gray16 sourceBaseRef = ref MemoryMarshal.GetReference(source);
            ref TPixel destBaseRef = ref MemoryMarshal.GetReference(destPixels);

            for (int i = 0; i < source.Length; i++)
            {
                ref Gray16 sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref TPixel dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromGray16(sp);
            }
        }

        /// <summary>
        /// A helper for <see cref="FromGray16(ReadOnlySpan{Gray16}, Span{TPixel})"/> that expects a byte span.
        /// The layout of the data in 'sourceBytes' must be compatible with <see cref="Gray16"/> layout.
        /// </summary>
        /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
        /// <param name="destPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void FromGray16Bytes(ReadOnlySpan<byte> sourceBytes, Span<TPixel> destPixels, int count)
        {
            this.FromGray16(MemoryMarshal.Cast<byte, Gray16>(sourceBytes).Slice(0, count), destPixels);
        }

        /// <summary>
        /// Converts all pixels of the 'sourcePixels` span to a span of <see cref="Gray16"/>-s.
        /// </summary>
        /// <param name="sourcePixels">The span of source pixels</param>
        /// <param name="destPixels">The destination span of <see cref="Gray16"/> data.</param>
        internal virtual void ToGray16(ReadOnlySpan<TPixel> sourcePixels, Span<Gray16> destPixels)
        {
            Guard.DestinationShouldNotBeTooShort(sourcePixels, destPixels, nameof(destPixels));

            ref TPixel sourceBaseRef = ref MemoryMarshal.GetReference(sourcePixels);
            ref Gray16 destBaseRef = ref MemoryMarshal.GetReference(destPixels);

            for (int i = 0; i < sourcePixels.Length; i++)
            {
                ref TPixel sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref Gray16 dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromScaledVector4(sp.ToScaledVector4());
            }
        }

        /// <summary>
        /// A helper for <see cref="ToGray16(ReadOnlySpan{TPixel}, Span{Gray16})"/> that expects a byte span as destination.
        /// The layout of the data in 'destBytes' must be compatible with <see cref="Gray16"/> layout.
        /// </summary>
        /// <param name="sourcePixels">The <see cref="Span{T}"/> to the source pixels.</param>
        /// <param name="destBytes">The <see cref="Span{T}"/> to the destination bytes.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void ToGray16Bytes(ReadOnlySpan<TPixel> sourcePixels, Span<byte> destBytes, int count)
        {
            this.ToGray16(sourcePixels.Slice(0, count), MemoryMarshal.Cast<byte, Gray16>(destBytes));
        }

        /// <summary>
        /// Converts all pixels in 'source` span of <see cref="Rgb24"/> into a span of <typeparamref name="TPixel"/>-s.
        /// </summary>
        /// <param name="source">The source <see cref="Span{T}"/> of <see cref="Rgb24"/> data.</param>
        /// <param name="destPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        internal virtual void FromRgb24(ReadOnlySpan<Rgb24> source, Span<TPixel> destPixels)
        {
            Guard.DestinationShouldNotBeTooShort(source, destPixels, nameof(destPixels));
            
            ref Rgb24 sourceBaseRef = ref MemoryMarshal.GetReference(source);
            ref TPixel destBaseRef = ref MemoryMarshal.GetReference(destPixels);

            for (int i = 0; i < source.Length; i++)
            {
                ref Rgb24 sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref TPixel dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromRgb24(sp);
            }
        }

        /// <summary>
        /// A helper for <see cref="FromRgb24(ReadOnlySpan{Rgb24}, Span{TPixel})"/> that expects a byte span.
        /// The layout of the data in 'sourceBytes' must be compatible with <see cref="Rgb24"/> layout.
        /// </summary>
        /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
        /// <param name="destPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void FromRgb24Bytes(ReadOnlySpan<byte> sourceBytes, Span<TPixel> destPixels, int count)
        {
            this.FromRgb24(MemoryMarshal.Cast<byte, Rgb24>(sourceBytes).Slice(0, count), destPixels);
        }

        /// <summary>
        /// Converts all pixels of the 'sourcePixels` span to a span of <see cref="Rgb24"/>-s.
        /// </summary>
        /// <param name="sourcePixels">The span of source pixels</param>
        /// <param name="destPixels">The destination span of <see cref="Rgb24"/> data.</param>
        internal virtual void ToRgb24(ReadOnlySpan<TPixel> sourcePixels, Span<Rgb24> destPixels)
        {
            Guard.DestinationShouldNotBeTooShort(sourcePixels, destPixels, nameof(destPixels));

            ref TPixel sourceBaseRef = ref MemoryMarshal.GetReference(sourcePixels);
            ref Rgb24 destBaseRef = ref MemoryMarshal.GetReference(destPixels);

            for (int i = 0; i < sourcePixels.Length; i++)
            {
                ref TPixel sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref Rgb24 dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromScaledVector4(sp.ToScaledVector4());
            }
        }

        /// <summary>
        /// A helper for <see cref="ToRgb24(ReadOnlySpan{TPixel}, Span{Rgb24})"/> that expects a byte span as destination.
        /// The layout of the data in 'destBytes' must be compatible with <see cref="Rgb24"/> layout.
        /// </summary>
        /// <param name="sourcePixels">The <see cref="Span{T}"/> to the source pixels.</param>
        /// <param name="destBytes">The <see cref="Span{T}"/> to the destination bytes.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void ToRgb24Bytes(ReadOnlySpan<TPixel> sourcePixels, Span<byte> destBytes, int count)
        {
            this.ToRgb24(sourcePixels.Slice(0, count), MemoryMarshal.Cast<byte, Rgb24>(destBytes));
        }

        /// <summary>
        /// Converts all pixels in 'source` span of <see cref="Rgba32"/> into a span of <typeparamref name="TPixel"/>-s.
        /// </summary>
        /// <param name="source">The source <see cref="Span{T}"/> of <see cref="Rgba32"/> data.</param>
        /// <param name="destPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        internal virtual void FromRgba32(ReadOnlySpan<Rgba32> source, Span<TPixel> destPixels)
        {
            Guard.DestinationShouldNotBeTooShort(source, destPixels, nameof(destPixels));
            
            ref Rgba32 sourceBaseRef = ref MemoryMarshal.GetReference(source);
            ref TPixel destBaseRef = ref MemoryMarshal.GetReference(destPixels);

            for (int i = 0; i < source.Length; i++)
            {
                ref Rgba32 sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref TPixel dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromRgba32(sp);
            }
        }

        /// <summary>
        /// A helper for <see cref="FromRgba32(ReadOnlySpan{Rgba32}, Span{TPixel})"/> that expects a byte span.
        /// The layout of the data in 'sourceBytes' must be compatible with <see cref="Rgba32"/> layout.
        /// </summary>
        /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
        /// <param name="destPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void FromRgba32Bytes(ReadOnlySpan<byte> sourceBytes, Span<TPixel> destPixels, int count)
        {
            this.FromRgba32(MemoryMarshal.Cast<byte, Rgba32>(sourceBytes).Slice(0, count), destPixels);
        }

        /// <summary>
        /// Converts all pixels of the 'sourcePixels` span to a span of <see cref="Rgba32"/>-s.
        /// </summary>
        /// <param name="sourcePixels">The span of source pixels</param>
        /// <param name="destPixels">The destination span of <see cref="Rgba32"/> data.</param>
        internal virtual void ToRgba32(ReadOnlySpan<TPixel> sourcePixels, Span<Rgba32> destPixels)
        {
            Guard.DestinationShouldNotBeTooShort(sourcePixels, destPixels, nameof(destPixels));

            ref TPixel sourceBaseRef = ref MemoryMarshal.GetReference(sourcePixels);
            ref Rgba32 destBaseRef = ref MemoryMarshal.GetReference(destPixels);

            for (int i = 0; i < sourcePixels.Length; i++)
            {
                ref TPixel sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref Rgba32 dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromScaledVector4(sp.ToScaledVector4());
            }
        }

        /// <summary>
        /// A helper for <see cref="ToRgba32(ReadOnlySpan{TPixel}, Span{Rgba32})"/> that expects a byte span as destination.
        /// The layout of the data in 'destBytes' must be compatible with <see cref="Rgba32"/> layout.
        /// </summary>
        /// <param name="sourcePixels">The <see cref="Span{T}"/> to the source pixels.</param>
        /// <param name="destBytes">The <see cref="Span{T}"/> to the destination bytes.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void ToRgba32Bytes(ReadOnlySpan<TPixel> sourcePixels, Span<byte> destBytes, int count)
        {
            this.ToRgba32(sourcePixels.Slice(0, count), MemoryMarshal.Cast<byte, Rgba32>(destBytes));
        }

        /// <summary>
        /// Converts all pixels in 'source` span of <see cref="Rgb48"/> into a span of <typeparamref name="TPixel"/>-s.
        /// </summary>
        /// <param name="source">The source <see cref="Span{T}"/> of <see cref="Rgb48"/> data.</param>
        /// <param name="destPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        internal virtual void FromRgb48(ReadOnlySpan<Rgb48> source, Span<TPixel> destPixels)
        {
            Guard.DestinationShouldNotBeTooShort(source, destPixels, nameof(destPixels));
            
            ref Rgb48 sourceBaseRef = ref MemoryMarshal.GetReference(source);
            ref TPixel destBaseRef = ref MemoryMarshal.GetReference(destPixels);

            for (int i = 0; i < source.Length; i++)
            {
                ref Rgb48 sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref TPixel dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromRgb48(sp);
            }
        }

        /// <summary>
        /// A helper for <see cref="FromRgb48(ReadOnlySpan{Rgb48}, Span{TPixel})"/> that expects a byte span.
        /// The layout of the data in 'sourceBytes' must be compatible with <see cref="Rgb48"/> layout.
        /// </summary>
        /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
        /// <param name="destPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void FromRgb48Bytes(ReadOnlySpan<byte> sourceBytes, Span<TPixel> destPixels, int count)
        {
            this.FromRgb48(MemoryMarshal.Cast<byte, Rgb48>(sourceBytes).Slice(0, count), destPixels);
        }

        /// <summary>
        /// Converts all pixels of the 'sourcePixels` span to a span of <see cref="Rgb48"/>-s.
        /// </summary>
        /// <param name="sourcePixels">The span of source pixels</param>
        /// <param name="destPixels">The destination span of <see cref="Rgb48"/> data.</param>
        internal virtual void ToRgb48(ReadOnlySpan<TPixel> sourcePixels, Span<Rgb48> destPixels)
        {
            Guard.DestinationShouldNotBeTooShort(sourcePixels, destPixels, nameof(destPixels));

            ref TPixel sourceBaseRef = ref MemoryMarshal.GetReference(sourcePixels);
            ref Rgb48 destBaseRef = ref MemoryMarshal.GetReference(destPixels);

            for (int i = 0; i < sourcePixels.Length; i++)
            {
                ref TPixel sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref Rgb48 dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromScaledVector4(sp.ToScaledVector4());
            }
        }

        /// <summary>
        /// A helper for <see cref="ToRgb48(ReadOnlySpan{TPixel}, Span{Rgb48})"/> that expects a byte span as destination.
        /// The layout of the data in 'destBytes' must be compatible with <see cref="Rgb48"/> layout.
        /// </summary>
        /// <param name="sourcePixels">The <see cref="Span{T}"/> to the source pixels.</param>
        /// <param name="destBytes">The <see cref="Span{T}"/> to the destination bytes.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void ToRgb48Bytes(ReadOnlySpan<TPixel> sourcePixels, Span<byte> destBytes, int count)
        {
            this.ToRgb48(sourcePixels.Slice(0, count), MemoryMarshal.Cast<byte, Rgb48>(destBytes));
        }

        /// <summary>
        /// Converts all pixels in 'source` span of <see cref="Rgba64"/> into a span of <typeparamref name="TPixel"/>-s.
        /// </summary>
        /// <param name="source">The source <see cref="Span{T}"/> of <see cref="Rgba64"/> data.</param>
        /// <param name="destPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        internal virtual void FromRgba64(ReadOnlySpan<Rgba64> source, Span<TPixel> destPixels)
        {
            Guard.DestinationShouldNotBeTooShort(source, destPixels, nameof(destPixels));
            
            ref Rgba64 sourceBaseRef = ref MemoryMarshal.GetReference(source);
            ref TPixel destBaseRef = ref MemoryMarshal.GetReference(destPixels);

            for (int i = 0; i < source.Length; i++)
            {
                ref Rgba64 sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref TPixel dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromRgba64(sp);
            }
        }

        /// <summary>
        /// A helper for <see cref="FromRgba64(ReadOnlySpan{Rgba64}, Span{TPixel})"/> that expects a byte span.
        /// The layout of the data in 'sourceBytes' must be compatible with <see cref="Rgba64"/> layout.
        /// </summary>
        /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
        /// <param name="destPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void FromRgba64Bytes(ReadOnlySpan<byte> sourceBytes, Span<TPixel> destPixels, int count)
        {
            this.FromRgba64(MemoryMarshal.Cast<byte, Rgba64>(sourceBytes).Slice(0, count), destPixels);
        }

        /// <summary>
        /// Converts all pixels of the 'sourcePixels` span to a span of <see cref="Rgba64"/>-s.
        /// </summary>
        /// <param name="sourcePixels">The span of source pixels</param>
        /// <param name="destPixels">The destination span of <see cref="Rgba64"/> data.</param>
        internal virtual void ToRgba64(ReadOnlySpan<TPixel> sourcePixels, Span<Rgba64> destPixels)
        {
            Guard.DestinationShouldNotBeTooShort(sourcePixels, destPixels, nameof(destPixels));

            ref TPixel sourceBaseRef = ref MemoryMarshal.GetReference(sourcePixels);
            ref Rgba64 destBaseRef = ref MemoryMarshal.GetReference(destPixels);

            for (int i = 0; i < sourcePixels.Length; i++)
            {
                ref TPixel sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref Rgba64 dp = ref Unsafe.Add(ref destBaseRef, i);

                dp.FromScaledVector4(sp.ToScaledVector4());
            }
        }

        /// <summary>
        /// A helper for <see cref="ToRgba64(ReadOnlySpan{TPixel}, Span{Rgba64})"/> that expects a byte span as destination.
        /// The layout of the data in 'destBytes' must be compatible with <see cref="Rgba64"/> layout.
        /// </summary>
        /// <param name="sourcePixels">The <see cref="Span{T}"/> to the source pixels.</param>
        /// <param name="destBytes">The <see cref="Span{T}"/> to the destination bytes.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void ToRgba64Bytes(ReadOnlySpan<TPixel> sourcePixels, Span<byte> destBytes, int count)
        {
            this.ToRgba64(sourcePixels.Slice(0, count), MemoryMarshal.Cast<byte, Rgba64>(destBytes));
        }
    }
}