<#
// Copyright (c) Six Labors and contributors.
// Licensed under the Apache License, Version 2.0.
#>
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// Copyright (c) Six Labors and contributors.
// Licensed under the Apache License, Version 2.0.

// <auto-generated />

<#
// Note use of MethodImplOptions.NoInlining. We have tests that are failing on certain architectures when
// AggresiveInlining is used. Confirmed on Intel i7-6600U in 64bit.
#>

using System;
using System.Numerics;
using System.Runtime.CompilerServices;

namespace SixLabors.ImageSharp.PixelFormats.PixelBlenders
{
    internal static partial class PorterDuffFunctions
    {

<# void GeneratePixelBlenders(string blender) { #>

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static Vector4 <#=blender#>Src(Vector4 backdrop, Vector4 source, float opacity)
        {
            source.W *= opacity;

            return source;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static Vector4 <#=blender#>SrcAtop(Vector4 backdrop, Vector4 source, float opacity)
        {
            source.W *= opacity;

            return Atop(backdrop, source, <#=blender#>(backdrop, source));
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static Vector4 <#=blender#>SrcOver(Vector4 backdrop, Vector4 source, float opacity)
        {
            source.W *= opacity;

            return Over(backdrop, source, <#=blender#>(backdrop, source));
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static Vector4 <#=blender#>SrcIn(Vector4 backdrop, Vector4 source, float opacity)
        {
            source.W *= opacity;

            return In(backdrop, source, <#=blender#>(backdrop, source));
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static Vector4 <#=blender#>SrcOut(Vector4 backdrop, Vector4 source, float opacity)
        {
            source.W *= opacity;

            return Out(backdrop, source);
        }

       [MethodImpl(MethodImplOptions.NoInlining)]
        public static Vector4 <#=blender#>Dest(Vector4 backdrop, Vector4 source, float opacity)
        {
            return backdrop;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static Vector4 <#=blender#>DestAtop(Vector4 backdrop, Vector4 source, float opacity)
        {
            source.W *= opacity;

            return Atop(source, backdrop, <#=blender#>(source, backdrop));
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static Vector4 <#=blender#>DestOver(Vector4 backdrop, Vector4 source, float opacity)
        {
            source.W *= opacity;

            return Over(source, backdrop, <#=blender#>(source, backdrop));
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static Vector4 <#=blender#>DestIn(Vector4 backdrop, Vector4 source, float opacity)
        {
            source.W *= opacity;

            return In(source, backdrop, <#=blender#>(source, backdrop));
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static Vector4 <#=blender#>DestOut(Vector4 backdrop, Vector4 source, float opacity)
        {
            source.W *= opacity;

            return Out(source, backdrop);
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static Vector4 <#=blender#>Xor(Vector4 backdrop, Vector4 source, float opacity)
        {
            source.W *= opacity;

            return Xor(backdrop, source);
        }   

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static Vector4 <#=blender#>Clear(Vector4 backdrop, Vector4 source, float opacity)
        {
            source.W *= opacity;

            return Clear(backdrop, source);
        }
<# } #>


<# void GenerateGenericPixelBlender(string blender, string composer) { #>        

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TPixel <#=blender#><#=composer#><TPixel>(TPixel backdrop, TPixel source, float opacity)
            where TPixel : struct, IPixel<TPixel>
        {
            opacity = opacity.Clamp(0, 1);
            TPixel dest = default;
            dest.PackFromScaledVector4(<#=blender#><#=composer#>(backdrop.ToScaledVector4(), source.ToScaledVector4(), opacity));
            return dest;
        }

<# } #>

<#

string[] composers = new []{         
    "Src",
    "SrcAtop",
    "SrcOver",
    "SrcIn",
    "SrcOut",
    "Dest",
    "DestAtop",
    "DestOver",
    "DestIn",
    "DestOut",
    "Clear",
    "Xor",
};

string[] blenders = new []{         
    "Normal",
    "Multiply",
    "Add",
    "Subtract",
    "Screen",
    "Darken",
    "Lighten",
    "Overlay",
    "HardLight"
}; 

    foreach(var blender in blenders)
    {        
        GeneratePixelBlenders(blender);        
        
        foreach(var composer in composers)
        {
            GenerateGenericPixelBlender(blender,composer);
        }
    }

#>
    }
}