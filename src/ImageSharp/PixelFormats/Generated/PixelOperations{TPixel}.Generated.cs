// Copyright (c) Six Labors and contributors.
// Licensed under the Apache License, Version 2.0.

// <auto-generated />
namespace SixLabors.ImageSharp.PixelFormats
{
    using System;
    using System.Runtime.CompilerServices;
    using System.Runtime.InteropServices;

    public partial class PixelOperations<TPixel>
    {
		
		/// <summary>
        /// Converts 'count' elements in 'source` span of <see cref="Rgba32"/> data to a span of <typeparamref name="TPixel"/>-s.
        /// </summary>
        /// <param name="source">The source <see cref="Span{T}"/> of <see cref="Rgba32"/> data.</param>
        /// <param name="destPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        internal virtual void PackFromRgba32(ReadOnlySpan<Rgba32> source, Span<TPixel> destPixels, int count)
        {
			GuardSpans(source, nameof(source), destPixels, nameof(destPixels), count);
            
            ref Rgba32 sourceRef = ref MemoryMarshal.GetReference(source);
            ref TPixel destRef = ref MemoryMarshal.GetReference(destPixels);

            var rgba = new Rgba32(0, 0, 0, 255);

            for (int i = 0; i < count; i++)
            {
                ref TPixel dp = ref Unsafe.Add(ref destRef, i);
                rgba = Unsafe.Add(ref sourceRef, i);
                dp.PackFromRgba32(rgba);
            }
        }
		
		/// <summary>
        /// A helper for <see cref="PackFromRgba32(ReadOnlySpan{Rgba32}, Span{TPixel}, int)"/> that expects a byte span.
        /// The layout of the data in 'sourceBytes' must be compatible with <see cref="Rgba32"/> layout.
        /// </summary>
        /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
        /// <param name="destPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void PackFromRgba32Bytes(ReadOnlySpan<byte> sourceBytes, Span<TPixel> destPixels, int count)
        {
            this.PackFromRgba32(MemoryMarshal.Cast<byte, Rgba32>(sourceBytes), destPixels, count);
        }
		
		/// <summary>
        /// Converts 'count' pixels in 'sourcePixels` span to a span of <see cref="Rgba32"/>-s.
        /// Bulk version of <see cref="IPixel.ToRgba32(ref Rgba32)"/>.
        /// </summary>
        /// <param name="sourcePixels">The span of source pixels</param>
        /// <param name="dest">The destination span of <see cref="Rgba32"/> data.</param>
        /// <param name="count">The number of pixels to convert.</param>
        internal virtual void ToRgba32(ReadOnlySpan<TPixel> sourcePixels, Span<Rgba32> dest, int count)
        {
            GuardSpans(sourcePixels, nameof(sourcePixels), dest, nameof(dest), count);

            ref TPixel sourceBaseRef = ref MemoryMarshal.GetReference(sourcePixels);
            ref Rgba32 destBaseRef = ref MemoryMarshal.GetReference(dest);

            for (int i = 0; i < count; i++)
            {
                ref TPixel sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref Rgba32 dp = ref Unsafe.Add(ref destBaseRef, i);
                sp.ToRgba32(ref dp);
            }
        }

		/// <summary>
        /// A helper for <see cref="ToRgba32(ReadOnlySpan{TPixel}, Span{Rgba32}, int)"/> that expects a byte span as destination.
        /// The layout of the data in 'destBytes' must be compatible with <see cref="Rgba32"/> layout.
        /// </summary>
        /// <param name="sourceColors">The <see cref="Span{T}"/> to the source colors.</param>
        /// <param name="destBytes">The <see cref="Span{T}"/> to the destination bytes.</param>
        /// <param name="count">The number of pixels to convert.</param>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void ToRgba32Bytes(ReadOnlySpan<TPixel> sourceColors, Span<byte> destBytes, int count)
        {
            this.ToRgba32(sourceColors, MemoryMarshal.Cast<byte, Rgba32>(destBytes), count);
        }
		
		/// <summary>
        /// Converts 'count' elements in 'source` span of <see cref="Bgra32"/> data to a span of <typeparamref name="TPixel"/>-s.
        /// </summary>
        /// <param name="source">The source <see cref="Span{T}"/> of <see cref="Bgra32"/> data.</param>
        /// <param name="destPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        internal virtual void PackFromBgra32(ReadOnlySpan<Bgra32> source, Span<TPixel> destPixels, int count)
        {
			GuardSpans(source, nameof(source), destPixels, nameof(destPixels), count);
            
            ref Bgra32 sourceRef = ref MemoryMarshal.GetReference(source);
            ref TPixel destRef = ref MemoryMarshal.GetReference(destPixels);

            var bgra = new Bgra32(0, 0, 0, 255);

            for (int i = 0; i < count; i++)
            {
                ref TPixel dp = ref Unsafe.Add(ref destRef, i);
                bgra = Unsafe.Add(ref sourceRef, i);
                dp.PackFromBgra32(bgra);
            }
        }
		
		/// <summary>
        /// A helper for <see cref="PackFromBgra32(ReadOnlySpan{Bgra32}, Span{TPixel}, int)"/> that expects a byte span.
        /// The layout of the data in 'sourceBytes' must be compatible with <see cref="Bgra32"/> layout.
        /// </summary>
        /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
        /// <param name="destPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void PackFromBgra32Bytes(ReadOnlySpan<byte> sourceBytes, Span<TPixel> destPixels, int count)
        {
            this.PackFromBgra32(MemoryMarshal.Cast<byte, Bgra32>(sourceBytes), destPixels, count);
        }
		
		/// <summary>
        /// Converts 'count' pixels in 'sourcePixels` span to a span of <see cref="Bgra32"/>-s.
        /// Bulk version of <see cref="IPixel.ToBgra32(ref Bgra32)"/>.
        /// </summary>
        /// <param name="sourcePixels">The span of source pixels</param>
        /// <param name="dest">The destination span of <see cref="Bgra32"/> data.</param>
        /// <param name="count">The number of pixels to convert.</param>
        internal virtual void ToBgra32(ReadOnlySpan<TPixel> sourcePixels, Span<Bgra32> dest, int count)
        {
            GuardSpans(sourcePixels, nameof(sourcePixels), dest, nameof(dest), count);

            ref TPixel sourceBaseRef = ref MemoryMarshal.GetReference(sourcePixels);
            ref Bgra32 destBaseRef = ref MemoryMarshal.GetReference(dest);

            for (int i = 0; i < count; i++)
            {
                ref TPixel sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref Bgra32 dp = ref Unsafe.Add(ref destBaseRef, i);
                sp.ToBgra32(ref dp);
            }
        }

		/// <summary>
        /// A helper for <see cref="ToBgra32(ReadOnlySpan{TPixel}, Span{Bgra32}, int)"/> that expects a byte span as destination.
        /// The layout of the data in 'destBytes' must be compatible with <see cref="Bgra32"/> layout.
        /// </summary>
        /// <param name="sourceColors">The <see cref="Span{T}"/> to the source colors.</param>
        /// <param name="destBytes">The <see cref="Span{T}"/> to the destination bytes.</param>
        /// <param name="count">The number of pixels to convert.</param>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void ToBgra32Bytes(ReadOnlySpan<TPixel> sourceColors, Span<byte> destBytes, int count)
        {
            this.ToBgra32(sourceColors, MemoryMarshal.Cast<byte, Bgra32>(destBytes), count);
        }
		
		/// <summary>
        /// Converts 'count' elements in 'source` span of <see cref="Rgb24"/> data to a span of <typeparamref name="TPixel"/>-s.
        /// </summary>
        /// <param name="source">The source <see cref="Span{T}"/> of <see cref="Rgb24"/> data.</param>
        /// <param name="destPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        internal virtual void PackFromRgb24(ReadOnlySpan<Rgb24> source, Span<TPixel> destPixels, int count)
        {
			GuardSpans(source, nameof(source), destPixels, nameof(destPixels), count);
            
            ref Rgb24 sourceRef = ref MemoryMarshal.GetReference(source);
            ref TPixel destRef = ref MemoryMarshal.GetReference(destPixels);

            var rgba = new Rgba32(0, 0, 0, 255);

            for (int i = 0; i < count; i++)
            {
                ref TPixel dp = ref Unsafe.Add(ref destRef, i);
                rgba.Rgb = Unsafe.Add(ref sourceRef, i);
                dp.PackFromRgba32(rgba);
            }
        }
		
		/// <summary>
        /// A helper for <see cref="PackFromRgb24(ReadOnlySpan{Rgb24}, Span{TPixel}, int)"/> that expects a byte span.
        /// The layout of the data in 'sourceBytes' must be compatible with <see cref="Rgb24"/> layout.
        /// </summary>
        /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
        /// <param name="destPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void PackFromRgb24Bytes(ReadOnlySpan<byte> sourceBytes, Span<TPixel> destPixels, int count)
        {
            this.PackFromRgb24(MemoryMarshal.Cast<byte, Rgb24>(sourceBytes), destPixels, count);
        }
		
		/// <summary>
        /// Converts 'count' pixels in 'sourcePixels` span to a span of <see cref="Rgb24"/>-s.
        /// Bulk version of <see cref="IPixel.ToRgb24(ref Rgb24)"/>.
        /// </summary>
        /// <param name="sourcePixels">The span of source pixels</param>
        /// <param name="dest">The destination span of <see cref="Rgb24"/> data.</param>
        /// <param name="count">The number of pixels to convert.</param>
        internal virtual void ToRgb24(ReadOnlySpan<TPixel> sourcePixels, Span<Rgb24> dest, int count)
        {
            GuardSpans(sourcePixels, nameof(sourcePixels), dest, nameof(dest), count);

            ref TPixel sourceBaseRef = ref MemoryMarshal.GetReference(sourcePixels);
            ref Rgb24 destBaseRef = ref MemoryMarshal.GetReference(dest);

            for (int i = 0; i < count; i++)
            {
                ref TPixel sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref Rgb24 dp = ref Unsafe.Add(ref destBaseRef, i);
                sp.ToRgb24(ref dp);
            }
        }

		/// <summary>
        /// A helper for <see cref="ToRgb24(ReadOnlySpan{TPixel}, Span{Rgb24}, int)"/> that expects a byte span as destination.
        /// The layout of the data in 'destBytes' must be compatible with <see cref="Rgb24"/> layout.
        /// </summary>
        /// <param name="sourceColors">The <see cref="Span{T}"/> to the source colors.</param>
        /// <param name="destBytes">The <see cref="Span{T}"/> to the destination bytes.</param>
        /// <param name="count">The number of pixels to convert.</param>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void ToRgb24Bytes(ReadOnlySpan<TPixel> sourceColors, Span<byte> destBytes, int count)
        {
            this.ToRgb24(sourceColors, MemoryMarshal.Cast<byte, Rgb24>(destBytes), count);
        }
		
		/// <summary>
        /// Converts 'count' elements in 'source` span of <see cref="Bgr24"/> data to a span of <typeparamref name="TPixel"/>-s.
        /// </summary>
        /// <param name="source">The source <see cref="Span{T}"/> of <see cref="Bgr24"/> data.</param>
        /// <param name="destPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        internal virtual void PackFromBgr24(ReadOnlySpan<Bgr24> source, Span<TPixel> destPixels, int count)
        {
			GuardSpans(source, nameof(source), destPixels, nameof(destPixels), count);
            
            ref Bgr24 sourceRef = ref MemoryMarshal.GetReference(source);
            ref TPixel destRef = ref MemoryMarshal.GetReference(destPixels);

            var rgba = new Rgba32(0, 0, 0, 255);

            for (int i = 0; i < count; i++)
            {
                ref TPixel dp = ref Unsafe.Add(ref destRef, i);
                rgba.Bgr = Unsafe.Add(ref sourceRef, i);
                dp.PackFromRgba32(rgba);
            }
        }
		
		/// <summary>
        /// A helper for <see cref="PackFromBgr24(ReadOnlySpan{Bgr24}, Span{TPixel}, int)"/> that expects a byte span.
        /// The layout of the data in 'sourceBytes' must be compatible with <see cref="Bgr24"/> layout.
        /// </summary>
        /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
        /// <param name="destPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void PackFromBgr24Bytes(ReadOnlySpan<byte> sourceBytes, Span<TPixel> destPixels, int count)
        {
            this.PackFromBgr24(MemoryMarshal.Cast<byte, Bgr24>(sourceBytes), destPixels, count);
        }
		
		/// <summary>
        /// Converts 'count' pixels in 'sourcePixels` span to a span of <see cref="Bgr24"/>-s.
        /// Bulk version of <see cref="IPixel.ToBgr24(ref Bgr24)"/>.
        /// </summary>
        /// <param name="sourcePixels">The span of source pixels</param>
        /// <param name="dest">The destination span of <see cref="Bgr24"/> data.</param>
        /// <param name="count">The number of pixels to convert.</param>
        internal virtual void ToBgr24(ReadOnlySpan<TPixel> sourcePixels, Span<Bgr24> dest, int count)
        {
            GuardSpans(sourcePixels, nameof(sourcePixels), dest, nameof(dest), count);

            ref TPixel sourceBaseRef = ref MemoryMarshal.GetReference(sourcePixels);
            ref Bgr24 destBaseRef = ref MemoryMarshal.GetReference(dest);

            for (int i = 0; i < count; i++)
            {
                ref TPixel sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref Bgr24 dp = ref Unsafe.Add(ref destBaseRef, i);
                sp.ToBgr24(ref dp);
            }
        }

		/// <summary>
        /// A helper for <see cref="ToBgr24(ReadOnlySpan{TPixel}, Span{Bgr24}, int)"/> that expects a byte span as destination.
        /// The layout of the data in 'destBytes' must be compatible with <see cref="Bgr24"/> layout.
        /// </summary>
        /// <param name="sourceColors">The <see cref="Span{T}"/> to the source colors.</param>
        /// <param name="destBytes">The <see cref="Span{T}"/> to the destination bytes.</param>
        /// <param name="count">The number of pixels to convert.</param>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void ToBgr24Bytes(ReadOnlySpan<TPixel> sourceColors, Span<byte> destBytes, int count)
        {
            this.ToBgr24(sourceColors, MemoryMarshal.Cast<byte, Bgr24>(destBytes), count);
        }
		
		/// <summary>
        /// Converts 'count' elements in 'source` span of <see cref="Argb32"/> data to a span of <typeparamref name="TPixel"/>-s.
        /// </summary>
        /// <param name="source">The source <see cref="Span{T}"/> of <see cref="Argb32"/> data.</param>
        /// <param name="destPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        internal virtual void PackFromArgb32(ReadOnlySpan<Argb32> source, Span<TPixel> destPixels, int count)
        {
			GuardSpans(source, nameof(source), destPixels, nameof(destPixels), count);
            
            ref Argb32 sourceRef = ref MemoryMarshal.GetReference(source);
            ref TPixel destRef = ref MemoryMarshal.GetReference(destPixels);

            var argb = new Argb32(0, 0, 0, 255);

            for (int i = 0; i < count; i++)
            {
                ref TPixel dp = ref Unsafe.Add(ref destRef, i);
                argb = Unsafe.Add(ref sourceRef, i);
				dp.PackFromArgb32(argb);
            }
        }
		
		/// <summary>
        /// A helper for <see cref="PackFromArgb32(ReadOnlySpan{Argb32}, Span{TPixel}, int)"/> that expects a byte span.
        /// The layout of the data in 'sourceBytes' must be compatible with <see cref="Argb32"/> layout.
        /// </summary>
        /// <param name="sourceBytes">The <see cref="ReadOnlySpan{T}"/> to the source bytes.</param>
        /// <param name="destPixels">The <see cref="Span{T}"/> to the destination pixels.</param>
        /// <param name="count">The number of pixels to convert.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void PackFromArgb32Bytes(ReadOnlySpan<byte> sourceBytes, Span<TPixel> destPixels, int count)
        {
            this.PackFromArgb32(MemoryMarshal.Cast<byte, Argb32>(sourceBytes), destPixels, count);
        }
		
		/// <summary>
        /// Converts 'count' pixels in 'sourcePixels` span to a span of <see cref="Argb32"/>-s.
        /// Bulk version of <see cref="IPixel.ToArgb32(ref Argb32)"/>.
        /// </summary>
        /// <param name="sourcePixels">The span of source pixels</param>
        /// <param name="dest">The destination span of <see cref="Argb32"/> data.</param>
        /// <param name="count">The number of pixels to convert.</param>
        internal virtual void ToArgb32(ReadOnlySpan<TPixel> sourcePixels, Span<Argb32> dest, int count)
        {
            GuardSpans(sourcePixels, nameof(sourcePixels), dest, nameof(dest), count);

            ref TPixel sourceBaseRef = ref MemoryMarshal.GetReference(sourcePixels);
            ref Argb32 destBaseRef = ref MemoryMarshal.GetReference(dest);

            for (int i = 0; i < count; i++)
            {
                ref TPixel sp = ref Unsafe.Add(ref sourceBaseRef, i);
                ref Argb32 dp = ref Unsafe.Add(ref destBaseRef, i);
                sp.ToArgb32(ref dp);
            }
        }

		/// <summary>
        /// A helper for <see cref="ToArgb32(ReadOnlySpan{TPixel}, Span{Argb32}, int)"/> that expects a byte span as destination.
        /// The layout of the data in 'destBytes' must be compatible with <see cref="Argb32"/> layout.
        /// </summary>
        /// <param name="sourceColors">The <see cref="Span{T}"/> to the source colors.</param>
        /// <param name="destBytes">The <see cref="Span{T}"/> to the destination bytes.</param>
        /// <param name="count">The number of pixels to convert.</param>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void ToArgb32Bytes(ReadOnlySpan<TPixel> sourceColors, Span<byte> destBytes, int count)
        {
            this.ToArgb32(sourceColors, MemoryMarshal.Cast<byte, Argb32>(destBytes), count);
        }
		
	}
}