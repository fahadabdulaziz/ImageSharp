<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
// Copyright (c) Six Labors and contributors.
// Licensed under the Apache License, Version 2.0.

// <auto-generated />

using SixLabors.ImageSharp.PixelFormats.Utils;
using System;
using System.Buffers;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
<#+
	static readonly string[] CommonPixelTypes = { "Argb32", "Bgr24", "Bgra32", "Gray8", "Gray16", "Rgb24", "Rgba32", "Rgb48", "Rgba64" };

	static readonly string[] Optimized32BitTypes = { "Rgba32", "Argb32", "Bgra32" };
	
	// Types with Rgba32-combatible to/from Vector4 conversion
	static readonly string[] Rgba32CompatibleTypes = { "Argb32", "Bgra32", "Rgb24", "Bgr24" };

	void GenerateDefaultSelfConversionMethods(string pixelType)
    {
		#>

			/// <inheritdoc />
            internal override void From<#=pixelType#>(Configuration configuration, ReadOnlySpan<<#=pixelType#>> source, Span<<#=pixelType#>> destPixels)
            {
				Guard.NotNull(configuration, nameof(configuration));
                Guard.DestinationShouldNotBeTooShort(source, destPixels, nameof(destPixels));

                source.CopyTo(destPixels);
            }

            /// <inheritdoc />
            internal override void To<#=pixelType#>(Configuration configuration, ReadOnlySpan<<#=pixelType#>> sourcePixels, Span<<#=pixelType#>> destPixels)
            {
				Guard.NotNull(configuration, nameof(configuration));
                Guard.DestinationShouldNotBeTooShort(sourcePixels, destPixels, nameof(destPixels));

                sourcePixels.CopyTo(destPixels);
            }

		<#+
    }

	void GenerateDefaultConvertToMethod(string fromPixelType, string toPixelType)
    {
        #>

			/// <inheritdoc />
            internal override void To<#=toPixelType#>(Configuration configuration, ReadOnlySpan<<#=fromPixelType#>> sourcePixels, Span<<#=toPixelType#>> destPixels)
            {
				Guard.NotNull(configuration, nameof(configuration));
                Guard.DestinationShouldNotBeTooShort(sourcePixels, destPixels, nameof(destPixels));

                ref <#=fromPixelType#> sourceRef = ref MemoryMarshal.GetReference(sourcePixels);
                ref <#=toPixelType#> destRef = ref MemoryMarshal.GetReference(destPixels);

                for (int i = 0; i < sourcePixels.Length; i++)
                {
                    ref <#=fromPixelType#> sp = ref Unsafe.Add(ref sourceRef, i);
                    ref <#=toPixelType#> dp = ref Unsafe.Add(ref destRef, i);

                    dp.From<#=fromPixelType#>(sp);
                }
            }
		<#+
    }

	void GenerateOptimized32BitConversionMethods(string thisPixelType, string otherPixelType)
	{
		#>
			/// <inheritdoc />
			internal override void To<#=otherPixelType#>(Configuration configuration, ReadOnlySpan<<#=thisPixelType#>> sourcePixels, Span<<#=otherPixelType#>> destPixels)
            {
				Guard.NotNull(configuration, nameof(configuration));
                Guard.DestinationShouldNotBeTooShort(sourcePixels, destPixels, nameof(destPixels));

                ref uint sourceRef = ref Unsafe.As<<#=thisPixelType#>,uint>(ref MemoryMarshal.GetReference(sourcePixels));
                ref uint destRef = ref Unsafe.As<<#=otherPixelType#>, uint>(ref MemoryMarshal.GetReference(destPixels));

                for (int i = 0; i < sourcePixels.Length; i++)
                {
                    uint sp = Unsafe.Add(ref sourceRef, i);
                    Unsafe.Add(ref destRef, i) = PixelConverter.From<#=thisPixelType#>.To<#=otherPixelType#>(sp);
                }
            }

			/// <inheritdoc />
            internal override void From<#=otherPixelType#>(Configuration configuration, ReadOnlySpan<<#=otherPixelType#>> sourcePixels, Span<<#=thisPixelType#>> destPixels)
            {
				Guard.NotNull(configuration, nameof(configuration));
                Guard.DestinationShouldNotBeTooShort(sourcePixels, destPixels, nameof(destPixels));
            
                ref uint sourceRef = ref Unsafe.As<<#=otherPixelType#>,uint>(ref MemoryMarshal.GetReference(sourcePixels));
                ref uint destRef = ref Unsafe.As<<#=thisPixelType#>, uint>(ref MemoryMarshal.GetReference(destPixels));

                for (int i = 0; i < sourcePixels.Length; i++)
                {
                    uint sp = Unsafe.Add(ref sourceRef, i);
                    Unsafe.Add(ref destRef, i) = PixelConverter.From<#=otherPixelType#>.To<#=thisPixelType#>(sp);
                }
            }
		<#+
    }

	void GenerateRgba32CompatibleVector4ConversionMethods(string pixelType)
	{
		#>
			
			/// <inheritdoc />
			internal override void FromVector4(Configuration configuration, ReadOnlySpan<Vector4> sourceVectors, Span<<#=pixelType#>> destPixels)
			{
				Vector4Converters.RgbaCompatible.FromVector4(configuration, this, sourceVectors, destPixels, false);
			}

			/// <inheritdoc />
			internal override void ToVector4(Configuration configuration, ReadOnlySpan<<#=pixelType#>> sourcePixels, Span<Vector4> destVectors)
			{
				Vector4Converters.RgbaCompatible.ToVector4(configuration, this, sourcePixels, destVectors, false);
			}

			/// <inheritdoc />
			internal override void FromScaledVector4(Configuration configuration, ReadOnlySpan<Vector4> sourceVectors, Span<<#=pixelType#>> destPixels)
			{
				Vector4Converters.RgbaCompatible.FromVector4(configuration, this, sourceVectors, destPixels, true);
			}

			/// <inheritdoc />
			internal override void ToScaledVector4(Configuration configuration, ReadOnlySpan<<#=pixelType#>> sourcePixels, Span<Vector4> destVectors)
			{
				Vector4Converters.RgbaCompatible.ToVector4(configuration, this, sourcePixels, destVectors, true);
			}

		<#+
    }

	void GenerateAllDefaultConversionMethods(string pixelType)
	{
		GenerateDefaultSelfConversionMethods(pixelType);

		if (Rgba32CompatibleTypes.Contains(pixelType))
		{
			GenerateRgba32CompatibleVector4ConversionMethods(pixelType);
        }

		var matching32BitTypes = Optimized32BitTypes.Contains(pixelType) ?
			Optimized32BitTypes.Where(p => p != pixelType) :
			Enumerable.Empty<string>();

		foreach (string destPixelType in matching32BitTypes)
		{
			GenerateOptimized32BitConversionMethods(pixelType, destPixelType);
        }

		var otherCommonNon32Types = CommonPixelTypes
			.Where(p => p != pixelType)
			.Except(matching32BitTypes);

		foreach (string destPixelType in otherCommonNon32Types)
		{
			GenerateDefaultConvertToMethod(pixelType, destPixelType);
        }
    }
#>